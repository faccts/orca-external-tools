"""
Classes with basic functionalities provided by the oet.

Provides
--------
class: BaseCalc(ABC)
    Class for basic calculators. Derive from this class if
    you rely purely on executables
class: CalcServer(BaseCalc)
    Extends the BaseCalc for necessary routines required for
    running on a server. Derive from this class if you plan
    using it in a server/client layout (e.g. heavy imports)
"""

import sys
import os
from typing import Any
from abc import abstractmethod, ABC
from pathlib import Path

from oet.core.misc import (
    check_multi_progs,
    check_path,
    read_input,
    write_output,
    nat_from_xyzfile,
)
from argparse import ArgumentParser


class BaseCalc(ABC):
    """
    Abstract base class with basic functionality.
    Wrapper classes should inherit.
    """

    # Minimal Python version required;
    # Overwrite in wrapper if you require newer versions
    minimal_python_version: tuple[int, int] = (3, 10)
    # Path and file names
    # --------------------
    # Input file name
    inputfile_path: Path
    # Basename of the calculation
    basename: str
    # Output file read by ORCA
    orca_engrad: Path
    # Output file of program
    prog_out: Path
    # Path to executable
    prog_path: Path

    def __init__(self):
        """
        Initialize variables of class
        """

    @property
    @abstractmethod
    def PROGRAM_KEYS(self) -> set[str]:
        """Set of executables to search for in Path."""
        pass

    def run(
        self,
        inputfile: str,
        settings: dict,
        args_not_parsed: list[str] = [],
        directory: Path | None = None,
    ) -> None:
        """
        Main routine that computes energy and gradient based on inputfile

        Parameters
        ----------
        inputfile: str
            Name of the inputfile generated by ORCA
        settings: dict
            Special settings for each calculation defined by respective arg parser extension
        args_not_parsed: list[str], default: []
            Arguments not parsed. Might be provided directly to executing program
        directory: Path
            Where to run the calculation

        Raises
        ------
        RuntimeError: If parsing or energy/gradient calculation failed
        """
        # Check if python version matches requirements if redefined by subclass
        self._check_python_version()
        # Where to run the calculation (default is CWD)
        if directory is None:
            directory = Path(os.getcwd())
        # Check validity of and set the input file path
        self.inputfile_path = check_path(file=directory / Path(inputfile))
        # Set filenames and paths according to inputfile name
        self.set_names(inputfile=inputfile, directory=directory)
        # Read inputfile and store it as dictionary
        orca_input = self._read_input(inputfile=self.inputfile_path)
        # Run the routine performing actual calculation
        try:
            energy, gradient = self.calc(
                orca_input=orca_input,
                directory=directory,
                args_not_parsed=args_not_parsed,
                **settings,
            )

        except Exception as e:
            raise RuntimeError(f"Failed to compute energy and/or gradient: {e}")
        # Get number of atoms
        nat = nat_from_xyzfile(directory / Path(orca_input["xyz_file"]))
        # Write ORCA input
        write_output(
            filename=self.orca_engrad, nat=nat, etot=energy, grad=gradient
        )

    def set_names(self, inputfile: str, directory: Path) -> None:
        """
        Set the most important filenames as object variables.

        Parameters
        ----------
        inputfile: str
            Name of the input file
        directory: Path
            Path to the directory, where the calculation takes place
        """
        self.basename = inputfile.removesuffix(".extinp.tmp")
        self.orca_engrad = directory / Path(self.basename + ".engrad")
        self.prog_out = directory / Path(self.basename + ".tmp.out").resolve()

    def parse_args(self, input: list[str] | None = None) -> tuple[str, dict, list[str]]:
        """
        Main parser
        Can be extended by the subclasses with extend_parser routine

        Parameters
        ----------
        input: list[str] | None, default: None
            Optional list of arguments to parse. If not given, cmd arguments are used

        Returns
        -------
        str: Name of inputfile
        dict: Dictionary of parsed arguments
        list[str]: Remaining arguments parsed by the subclasses
        """
        # Setup new parser
        parser = ArgumentParser(
            prog="ORCA otool",
            description="ORCA external tools wrapper.",
        )
        parser.add_argument("inputfile")
        # Extend parser with in subclass defined arguments
        self.extend_parser(parser)

        # Argument parsing
        try:
            args, args_not_parsed = parser.parse_known_args(input)
        except Exception as e:
            raise RuntimeError(f"Failed to parse arguments: {e}")
        # Get inputfile
        inputfile = args.inputfile
        # Remove the inputfile from aragparser as it is already parsed
        delattr(args, "inputfile")

        return inputfile, vars(args), args_not_parsed

    def extend_parser(self, parser: ArgumentParser) -> None:
        """
        Subclasses override this to add custom arguments.
        
        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        pass

    @abstractmethod
    def calc(
        self, orca_input: dict, directory: Path, args_not_parsed: list[str], *args: Any, **kwargs: Any
    ) -> tuple[float, list[float]]:
        """
        Main routing for calculating engrad.
        Gets information from input file and should return energy
        and optional gradient.

        Parameters
        ----------
        orca_input: dict
            Input written by ORCA containing:
                "xyz_file": xyzname,
                "chrg": charge,
                "mult": mult,
                "ncores": ncores,
                "dograd": dograd,
                "pointcharge_file": pointcharges
        directory: Path
            Directory where to work
        args_not_parsed: list[str]
            Additional arguments not parsed so far

        Returns
        -------
        float: electronic energy in Hartree
        list[float]: gradient in Hartree/bohr, leave empty if dograd=False
        """
        pass

    def set_program_path(self, exe_path_or_name: str | Path | None = None) -> None:
        """
        Checks for executable of program

        Params
        ------
        exe_path_or_name: str | Path, default None
            Full path to an executable or just its name.
            If not provided, the PROGRAM_KEYS are automatically checked
        """
        prog_path = None
        if exe_path_or_name:
            try:
                prog_path = check_path(exe_path_or_name)
            except Exception as e:
                print(f"Warning: Provided executable not valid: {e}")
                print("Try to detect standard executables.")

        # Check the standard PROGRAM_KEYS for executables
        if not prog_path:
            prog_path = check_multi_progs(self.PROGRAM_KEYS)

        # If no executable was found, raise an error
        if not prog_path:
            raise FileNotFoundError(
                f"Could not find a valid executable from PROGRAM_KEYS: {self.PROGRAM_KEYS}"
            )

        self.prog_path = prog_path

    def _read_input(self, inputfile: str | Path) -> dict:
        """
        Reads the ORCA input file and result a dictionary with infos

        Parameters
        ----------
        inputfile: str | Path
            Filename of input

        Returns
        -------
        dict: Dictonary with orca input
        """
        xyzname, charge, mult, ncores, dograd, pointcharges = read_input(
            inputfile=inputfile
        )
        orca_input = {
            "xyz_file": xyzname,
            "chrg": charge,
            "mult": mult,
            "ncores": ncores,
            "dograd": dograd,
            "pointcharge_file": pointcharges,
        }

        return orca_input
    
    def setup(self, args: dict) -> dict:
        """
        Only overwrite for using import heavy stuff that should run on server
        Sets class variables/objects that should remain identical for multiple calculations
        Usually the import heavy stuff
        Is called by the server and setup on start
        Afterwards, it is not changed
        Uses a dictionary to filter relevant settings, comes usually from command-line arguments
        Returns the respective dict where the processed arguments are removed

        Parameters
        ----------
        args: dict
            Arguments provided via cmd

        Returns
        -------
        dict: Arguments where all entries are removed that were processed
        """
        pass

    def _check_python_version(self) -> None:
        """
        Checks wether the Python version matches the minimum requirement

        Raises
        ------
        RuntimeError: If minimum requirement is not satisfied
        """
        if sys.version_info < self.minimal_python_version:
            raise RuntimeError(
                f"Python version must be higher than {self.minimal_python_version[0]}.{self.minimal_python_version[1]}"
            )

    def clean_files(self) -> None:
        """
        Deletes all files with basename, except .engrad and .xyz
        """
        for f in Path(".").glob(f"*{self.basename}*"):
            if f.name.endswith(".engrad"):
                continue  # Skip the .engrad file used by orca
            if f.name.endswith(".xyz"):
                continue  # Don't delete the xyz file
            f.unlink()


class CalcServer(BaseCalc):
    """
    Class for building a calculator that can also be used by a server.
    """


    def extend_parser(self, parser: ArgumentParser) -> None:
        """
        Extends the parser by options defined by the subclasses

        Parameters
        ----------
        parser: ArgumentParser
            Parser that is extended
        """
        self.extend_parser_setup(parser)
        self.extend_parser_settings(parser)

    def extend_parser_setup(self, parser: ArgumentParser) -> None:
        """
        Method that extends parser for setup related arguments

        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        pass

    def extend_parser_settings(self, parser: ArgumentParser) -> None:
        """
        Method that extends parser for calculation settings related arguments

        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        pass
