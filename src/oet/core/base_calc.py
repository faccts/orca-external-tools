"""
Classes with basic functionalities provided by the oet.

Provides
--------
class: BaseCalc(ABC)
    Class for basic calculators. Use if you use executables
class: CalcServer(BaseCalc)
    Extends the BaseCalc for necessary routines required for
    running on a server. Use if you plan on this (e.g. heavy imports)
"""

import sys
import os
from typing import Any
from abc import abstractmethod, ABC
from pathlib import Path
import subprocess

from oet.core.misc import (
    check_multi_progs,
    check_path,
    read_orca_input,
    write_orca_input,
    nat_from_xyz,
    print_filecontent,
    remove_file,
)
from argparse import ArgumentParser


class BaseCalc(ABC):
    """
    Abstract base class with basic functionality.
    Wrapper classes should inherit.
    """

    # Minimal Python version required;
    # Overwrite in wrapper if you require newer versions
    minimal_python_version: tuple[int, int] = (3, 10)
    # Path and file names
    # --------------------
    # Input file name
    inputfile_path: Path
    # Basename of the calculation
    basename: str
    # Output file read by ORCA
    orca_engrad: Path
    # Output file of program
    prog_out: Path
    # Path to executable
    prog_path: Path

    def __init__(self):
        """
        Initialize variables of class
        """

    @property
    @abstractmethod
    def PROGRAM_KEYS(self) -> set[str]:
        """Set of executables to search for in Path."""
        pass

    def run(
        self,
        inputfile: str,
        settings: dict,
        clear_args: list[str] = [],
        directory: Path | None = None,
    ) -> None:
        """
        Main routine that computes energy and gradient based on inputfile

        Parameters
        ----------
        inputfile: str
            Name of the inputfile generated by ORCA
        settings: dict
            Special settings for each calculation defined by respective arg parser extension
        clear_args: list[str], default: []
            Arguments not parsed. Might be provided directly to executing program
        directory: Path
            Where to run the calculation

        Raises
        ------
        RuntimeError: If parsing or energy/gradient calculation failed
        """
        # Check if python version matches requirements if redefined by subclass
        self.check_python_version()
        # Where to run the calculation (default is CWD)
        if directory is None:
            directory = Path(os.getcwd())
        # Check validity of and set the input file path
        self.inputfile_path = check_path(file=directory / Path(inputfile))
        # Set filenames and paths according to inputfile name
        self.set_names(inputfile=inputfile, directory=directory)
        # Read inputfile and store it as dictionary
        orca_input = self.read_input(inputfile=self.inputfile_path)
        # Run the routine performing actual calculation
        try:
            energy, gradient = self.calc(
                orca_input=orca_input,
                directory=directory,
                clear_args=clear_args,
                **settings,
            )

        except Exception as e:
            raise RuntimeError(f"Failed to compute energy and/or gradient: {e}")
        # Get number of atoms
        nat = self.nat_from_xyzfile(directory / Path(orca_input["xyz_file"]))
        # Write ORCA input
        self.write_orca_input(
            filename=self.orca_engrad, nat=nat, etot=energy, grad=gradient
        )

    def set_names(self, inputfile: str, directory: Path) -> None:
        """
        Set the most important filenames as object variables.

        Parameters
        ----------
        inputfile: str
            Name of the input file
        directory: Path
            Path to the directory, where the calculation takes place
        """
        self.basename = inputfile.removesuffix(".extinp.tmp")
        self.orca_engrad = directory / Path(self.basename + ".engrad")
        self.prog_out = directory / Path(self.basename + ".tmp.out").resolve()

    def parse_args(self, input: list[str] | None = None) -> tuple[str, dict, list[str]]:
        """
        Main parser
        Can be extended by the subclasses with extend_parser routine

        Parameters
        ----------
        input: list[str] | None, default: None
            Optional list of arguments to parse. If not given, cmd arguments are used

        Returns
        -------
        str: Name of inputfile
        dict: Dictionary of parsed arguments
        list[str]: Remaining arguments parsed by the subclasses
        """
        # Setup new parser
        parser = ArgumentParser(
            prog="ORCA otool",
            description="ORCA external tools wrapper.",
        )
        parser.add_argument("inputfile")
        # Extend parser with in subclass defined arguments
        self.extend_parser(parser)

        # Argument parsing
        try:
            args, clear_args = parser.parse_known_args(input)
        except Exception as e:
            raise RuntimeError(f"Failed to parse arguments: {e}")
        # Get inputfile
        inputfile = args.inputfile
        # Remove the inputfile from aragparser as it is already parsed
        delattr(args, "inputfile")

        return inputfile, vars(args), clear_args

    def extend_parser(self, parser: ArgumentParser) -> None:
        """
        Subclasses override this to add custom arguments.
        
        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        pass

    @abstractmethod
    def calc(
        self, orca_input: dict, directory: Path, clear_args: list[str], *args: Any, **kwargs: Any
    ) -> tuple[float, list[float]]:
        """
        Main routing for calculating engrad.
        Gets information from input file and should return energy
        and optional gradient.

        Parameters
        ----------
        orca_input: dict
            Input written by ORCA containing:
                "xyz_file": xyzname,
                "chrg": charge,
                "mult": mult,
                "ncores": ncores,
                "dograd": dograd,
                "pointcharge_file": pointcharges
        directory: Path
            Directory where to work
        clear_args: list[str]
            Additional arguments not parsed so far

        Returns
        -------
        float: electronic energy in Hartree
        list[float]: gradient in Hartree/bohr, leave empty if dograd=False
        """
        pass

    def set_program_path(self, exe_path_or_name: str | Path | None = None) -> None:
        """
        Checks for executable of program

        Params
        ------
        exe_path_or_name: str | Path, default None
            Full path to an executable or just its name.
            If not provided, the PROGRAM_KEYS are automatically checked
        """
        prog_path = None
        if exe_path_or_name:
            try:
                prog_path = check_path(exe_path_or_name)
            except Exception as e:
                print(f"Warning: Provided executable not valid: {e}")
                print("Try to detect standard executables.")

        # Check the standard PROGRAM_KEYS for executables
        if not prog_path:
            prog_path = check_multi_progs(self.PROGRAM_KEYS)

        # If no executable was found, raise an error
        if not prog_path:
            raise FileNotFoundError(
                f"Could not find a valid executable from PROGRAM_KEYS: {self.PROGRAM_KEYS}"
            )

        self.prog_path = prog_path

    def read_input(self, inputfile: str | Path) -> dict:
        """
        Reads the ORCA input file and result a dictionary with infos

        Parameters
        ----------
        inputfile: str | Path
            Filename of input

        Returns
        -------
        dict: Dictonary with orca input
        """
        xyzname, charge, mult, ncores, dograd, pointcharges = read_orca_input(
            inputfile=inputfile
        )
        orca_input = {
            "xyz_file": xyzname,
            "chrg": charge,
            "mult": mult,
            "ncores": ncores,
            "dograd": dograd,
            "pointcharge_file": pointcharges,
        }

        return orca_input
    
    def setup(self, args: dict) -> dict:
        """
        Only overwrite for using import heavy stuff that should run on server
        Sets class variables/objects that should remain identical for multiple calculations
        Usually the import heavy stuff
        Is called by the server and setup on start
        Afterwards, it is not changed
        Uses a dictionary to filter relevant settings, comes usually from command-line arguments
        Returns the respective dict where the processed arguments are removed

        Parameters
        ----------
        args: dict
            Arguments provided via cmd

        Returns
        -------
        dict: Arguments where all entries are removed that were processed
        """
        pass

    def check_python_version(self) -> None:
        """
        Checks wether the Python version matches the minimum requirement

        Raises
        ------
        RuntimeError: If minimum requirement is not satisfied
        """
        if sys.version_info < self.minimal_python_version:
            raise RuntimeError(
                f"Python version must be higher than {self.minimal_python_version[0]}.{self.minimal_python_version[1]}"
            )

    def run_command(
        self, command: str | Path, outname: str | Path, args: list[str]
    ) -> None:
        """
        Run the given command and redirect its STDOUT and STDERR to a file.
        Exits on a non-zero return code.

        Parameters
        ----------
        command : str | Path
            The command to run or path to an executable
        outname : str | Path
            The output file to be written to (overwritten!)
        args : list[str]
            arguments to be passed to the command
        """
        with open(outname, "w") as of:
            try:
                subprocess.run(
                    [str(command)] + args,
                    stdout=of,
                    stderr=subprocess.STDOUT,
                    check=True,
                )
            except subprocess.CalledProcessError as err:
                print(err)
                sys.exit(err.returncode)

    def write_orca_input(
        self,
        filename: Path,
        nat: int,
        etot: float,
        grad: list[float] | None = None,
    ) -> None:
        """
        Writes an input for ORCA similar to external-tools format.
        Attributes
        ----------
        self._inputfile: Path
            Path to file to write to.
        filename: str
            Filename that is written to
        nat: int
            number of atoms
        etot: int
            total energy in Hartree
        grad: list[float]
            gradients as plain list in Hartee/Bohr
            if not present or empty, it is not written
        Raises
        ------
        RuntimeError: If writing to file didn't work
        """
        write_orca_input(filename, nat, etot, grad)

    def write_to_file(self, content: str | int | float, file: str) -> None:
        """
        Writes any str/int/float to file

        Parameters
        ----------
        content: str | int | float
            Content to be written to file
        file: str
            Name of file to be written to
        """
        # first check whether files are present and delete them if so
        remove_file(file)
        # Then, write to file
        file_path = Path(file)
        with open(file_path, "w") as f:
            f.write(f"{content}\n")

    def mult_to_nue(self, mult: int) -> int:
        """
        Converts multiplicity to number of unpaired electrons.

        Parameters
        ----------
        mult: int
            Multiplicity

        Returns
        -------
        int: number of unpaired electrons
        """

        return mult - 1

    def nat_from_xyzfile(self, xyz_file: str | Path) -> int:
        """
        Read number of atoms from xyz file

        Parameters
        ----------
        xyzname: str | Path
            Name of xyz file

        Returns
        -------
        int: number of atoms
        """

        return nat_from_xyz(xyz_file=xyz_file)

    def clean_files(self) -> None:
        """
        Deletes all files with basename, except .engrad and .xyz
        """
        for f in Path(".").glob(f"*{self.basename}*"):
            if f.name.endswith(".engrad"):
                continue  # Skip the .engrad file used by orca
            if f.name.endswith(".xyz"):
                continue  # Don't delete the xyz file
            f.unlink()

    def print_filecontent(self, outfile: str | Path) -> None:
        """
        Print the file content, e.g. the output file, to STDOUT

        Parameters
        ----------
        outfile : str | Path
            The output file to print
        """
        print_filecontent(outfile=outfile)

    def check_path(self, file: str | Path) -> Path:
        """
        Checks for Path

        Parameters
        ----------
        file: str | Path
            Either string to file in PATH
            or Path to file

        Returns
        -------
        Path: Path to file
        """
        return check_path(file=file)

    def xyzfile_to_at_coord(
        self, xyzname: str | Path
    ) -> tuple[list[str], list[tuple[float, float, float]]]:
        """Read an XYZ file and return the atom types and coordinates.

        Parameters
        ----------
        xyzname : str | Path
            The XYZ file to read.

        Returns
        -------
        atom_types: list[str]
            A list of element symbols in order.
        coordinates: list[tuple[float, float, float]]
            A list of (x, y, z) coordinates.
        """
        atom_types = []
        coordinates = []
        xyzname = self.check_path(xyzname)
        with xyzname.open() as xyzf:
            natoms = int(xyzf.readline().strip())
            xyzf.readline()
            for _ in range(natoms):
                line = xyzf.readline()
                if not line:
                    break
                parts = line.split()
                atom_types.append(parts[0])
                coords = tuple(float(c) for c in parts[1:4])
                coordinates.append(coords)
        return atom_types, coordinates


class CalcServer(BaseCalc):
    """
    Class for building a calculator that can also be used by a server.
    """


    def extend_parser(self, parser: ArgumentParser) -> None:
        """
        Extends the parser by options defined by the subclasses

        Parameters
        ----------
        parser: ArgumentParser
            Parser that is extended
        """
        self.extend_parser_setup(parser)
        self.extend_parser_settings(parser)

    def extend_parser_setup(self, parser: ArgumentParser) -> None:
        """
        Method that extends parser for setup related arguments

        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        pass

    def extend_parser_settings(self, parser: ArgumentParser) -> None:
        """
        Method that extends parser for calculation settings related arguments

        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        pass
