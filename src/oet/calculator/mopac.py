#!/usr/bin/env python3
"""
This is a simple wrapper for the MOPAC binary (github.com/openmopac/mopac),
compatible with ORCA's ExtTool interface.
It converts ORCA-generated input files to a MOPAC input, runs MOPAC,
parses its output, converts energies and gradients from kcal to atomic units,
and writes the energy/gradient file for ORCA.

Provides
--------
class: MopacCalc(BaseCalc)
    Class for performing a MOPAC calculation together with ORCA
main: function
    Main function
"""

import sys
from argparse import ArgumentParser
from pathlib import Path
from oet.core.base_calc import BaseCalc
from oet.core.misc import run_command, nat_from_xyzfile, print_filecontent, check_path


class MopacCalc(BaseCalc):
    @property
    def PROGRAM_KEYS(self) -> set[str]:
        """Program keys to search for in PATH"""
        return {"mopac", "otools_mopac"}

    def extend_parser(self, parser: ArgumentParser):
        """Add mopac parsing options.

        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        parser.add_argument(
            "--method",
            default="PM6-D3H4X",
            dest="method",
            help="MOPAC method (default: PM6-D3H4X)",
        )
        parser.add_argument(
            "-e", "--exe", dest="prog", help="Path to the MOPAC executable"
        )

    def write_mopac_input(
        self,
        xyz_file: str | Path,
        method: str,
        mult: int,
        chrg: int,
        ncores: int,
        dograd: bool,
        output_file: str | Path,
    ) -> None:
        """
        Create a MOPAC input file from the ORCA input variables and the provided XYZ file.

        The MOPAC input file format is as follows:

        {method} 1SCF XYZ MS={spin} CHARGE={charge} THREADS={ncores}[ UHF][ GRADIENTS]
        Generated by ORCA-to-MOPAC wrapper

        <coordinates from xyz file>

        Here the spin is calculated correctly from the mult (2S+1) using:
            S = (mult - 1) * 0.5

        Also:
        - "CHARGE={charge}" reports the total charge of the system.
        - "THREADS={ncores}" sets the number of processors.
        - "UHF" is appended if mult is not 1.
        - "GRADIENTS" is appended if gradient computation is requested.

        Parameters
        ----------
        xyz_file: str
            Filename of xyz structure
        method: str
            Method to compute with
        mult: int
            Multiplicity
        chrg: int
            Molecular charge
        ncores: int
            Number of cores to use
        dograd: bool
            Whether to do a gradient calculation or not
        output_file: str
            What file to pipe the output to
        """
        xyz_file = check_path(xyz_file)
        with xyz_file.open() as f:
            lines = f.readlines()
        # If file is in standard XYZ format (first line is atom count), skip first two lines.
        if lines and lines[0].strip().isdigit():
            coord_lines = lines[2:]
        else:
            coord_lines = lines

        spin = (mult - 1) * 0.5
        # Format spin to one decimal place (e.g., "0.5" for a doublet)
        spin_formatted = f"{spin:.1f}"
        header = f"{method} 1SCF XYZ MS={spin_formatted} CHARGE={chrg} THREADS={ncores}"
        if mult != 1:
            header += " UHF"
        if dograd:
            header += " GRADIENTS"

        with Path(output_file).open("w") as f_out:
            f_out.write(header + "\n")
            f_out.write("Generated by ORCA-to-MOPAC wrapper\n\n")
            for line in coord_lines:
                f_out.write(line)

    def read_mopac_out(self, natoms: int, dograd: bool) -> tuple[float, list[float]]:
        """
        Read the output from MOPAC.

        It extracts the energy (by finding the "FINAL HEAT OF FORMATION" line)
        and, if requested, reads the gradient from the corresponding output block.

        The energy is originally in kcal/mol and the gradient components in kcal/Å.
        They are converted to atomic units as follows:
          - Energy: 1 kcal/mol = 1/627.5095 Eh
          - Gradient: 1 (kcal/Å) = (1/627.5095) / 1.889725988 Eh/Bohr

        Parameters
        ----------
        natoms : int
            Number of atoms in the system.
        dograd : bool
            Whether to read the gradient.

        Returns
        -------
        energy : The computed energy in Eh.
        gradient : The gradient in Eh/Bohr (if computed), as a flat list of floats.
        """
        # Define conversion factors.
        KCAL_TO_EH = 1 / 627.5095  # 1 kcal/mol in Eh
        ANGSTROM_TO_BOHR = 1.889725988  # 1 Å in bohr
        GRAD_CONV_FACTOR = KCAL_TO_EH / ANGSTROM_TO_BOHR

        energy = None
        gradient = []
        mopac_out = check_path(self.prog_out)
        mopac_results_out = check_path(self.prog_out)
        print("Checking:", mopac_results_out)
        with mopac_results_out.open() as f:
            for line in f:
                if "FINAL HEAT OF FORMATION" in line:
                    # Expect a line like: "FINAL HEAT OF FORMATION =   -123.456 ..."
                    tokens = line.split()
                    if "=" in tokens:
                        idx = tokens.index("=")
                        try:
                            # Convert energy from kcal/mol to Eh.
                            energy = float(tokens[idx + 1]) * KCAL_TO_EH
                        except (IndexError, ValueError):
                            pass
                        break

        if energy is None:
            outfile = Path(self.basename + ".out")
            mopac_results_out = check_path(outfile)
            with outfile.open() as f:
                for line in f:
                    if "FINAL HEAT OF FORMATION" in line:
                        # Expect a line like: "FINAL HEAT OF FORMATION =   -123.456 ..."
                        tokens = line.split()
                        if "=" in tokens:
                            idx = tokens.index("=")
                            try:
                                # Convert energy from kcal/mol to Eh.
                                energy = float(tokens[idx + 1]) * KCAL_TO_EH
                            except (IndexError, ValueError):
                                pass
                            break

        if energy is None:
            print("Could not find energy in MOPAC output.")
            sys.exit(1)

        if dograd:
            # Read the entire output file into memory.
            with mopac_out.open() as f:
                lines = f.readlines()
            with mopac_results_out.open() as f:
                lines2 = f.readlines()
            lines = lines + lines2

            # Locate the header of the gradient table.
            header_idx = None
            for i, line in enumerate(lines):
                if "PARAMETER" in line and "GRADIENT" in line:
                    header_idx = i + 1  # Data is expected to start on the next line.
                    break
            if header_idx is None:
                print("Could not find gradient header in MOPAC output.")
                sys.exit(1)

            # Process the gradient table: each line should correspond to one gradient component.
            for line in lines[header_idx:]:
                line = line.strip()
                if not line:
                    continue  # Skip empty lines.
                tokens = line.split()
                # Expect at least 7 tokens:
                # [0]: parameter index, [1]: atom number, [2]: element,
                # [3] & [4]: coordinate description (e.g., "CARTESIAN X"),
                # [5]: VALUE, [6]: GRADIENT, [7] (if present): unit.
                if len(tokens) < 7:
                    continue
                try:
                    # Extract the gradient value (seventh token) in kcal/Å and convert it to Eh/Bohr.
                    grad_val = float(tokens[6]) * GRAD_CONV_FACTOR
                except ValueError:
                    continue
                gradient.append(grad_val)
                # Stop once we have gathered the expected 3 * natoms entries.
                if len(gradient) >= 3 * natoms:
                    break

            if len(gradient) != 3 * natoms:
                print(
                    f"Gradient entries ({len(gradient)}) do not match expected 3x number of atoms ({3 * natoms})."
                )
                sys.exit(1)

        return energy, gradient

    def run_mopac(
        self,
        mopac_inp: str,
        args: list[str],
    ) -> None:
        """
        Run the MOPAC program with the given input file and redirect its STDOUT and STDERR to a logfile.

        Parameters
        ----------
        mopac_inp : str
            The generated MOPAC input file.
        args: list[str]
            Additional arguments not parsed so far
        """
        # Add method to the clear args
        args.insert(0, mopac_inp)
        run_command(self.prog_path, self.prog_out, args)

    def calc(
        self,
        orca_input: dict,
        directory: Path,
        args_not_parsed: list[str],
        prog: str,
        method: str,
    ) -> tuple[float, list[float]]:
        """
        Routine for calculating energy and optional gradient.
        Writes ORCA output

        Parameters
        ----------
        orca_input: dict
            Input parameters
        directory: Path
            Directory where to work in
        args_not_parsed: list[str]
            Arguments not parsed so far
        prog: str
            Which program executable to use
        method: sre
            Method to perform the calculation with

        Returns
        -------
        float: energy
        list[float]: gradients
        """
        # Get the information needed
        xyz_file = orca_input["xyz_file"]
        chrg = orca_input["chrg"]
        mult = orca_input["mult"]
        ncores = orca_input["ncores"]
        dograd = orca_input["dograd"]

        xyz_file = directory / Path(xyz_file)

        # Set and check the program path if its executable
        self.set_program_path(prog)
        print("Using executable ", self.prog_path)
        # Set name for MOPAC input
        mopac_inp = self.basename + ".mop"

        # Write Mopac input
        self.write_mopac_input(
            xyz_file=xyz_file,
            method=method,
            mult=mult,
            chrg=chrg,
            ncores=ncores,
            dograd=dograd,
            output_file=mopac_inp,
        )

        # run mopac
        self.run_mopac(mopac_inp=mopac_inp, args=args_not_parsed)

        # get the number of atoms from the xyz file
        natoms = nat_from_xyzfile(xyz_file=xyz_file)

        # parse the mopac output
        energy, gradient = self.read_mopac_out(natoms=natoms, dograd=dograd)

        # Print filecontent
        print_filecontent(outfile=self.prog_out)

        # Delete files
        self.clean_files()

        return energy, gradient


def main():
    """
    Main routine for execution
    """
    calculator = MopacCalc()
    inputfile, args, args_not_parsed = calculator.parse_args()
    calculator.run(inputfile=inputfile, settings=args, args_not_parsed=args_not_parsed)


# Python entry point
if __name__ == "__main__":
    main()
