#!/usr/bin/env python3
"""
This is a simple wrapper for the MOPAC binary (github.com/openmopac/mopac),
compatible with ORCA's ExtTool interface.
It converts ORCA-generated input files to a MOPAC input, runs MOPAC,
parses its output, converts energies and gradients from kcal to atomic units,
and writes the energy/gradient file for ORCA.

Provides
--------
class: MopacCalc(BaseCalc)
    Class for performing a MOPAC calculation together with ORCA
main: function
    Main function
"""

import sys
from argparse import ArgumentParser
from pathlib import Path
from typing import Any

from oet.core.base_calc import BaseCalc, CalculationData
from oet.core.misc import (
    ENERGY_CONVERSION,
    LENGTH_CONVERSION,
    check_path,
    nat_from_xyzfile,
    print_filecontent,
    run_command,
)


class MopacCalc(BaseCalc):
    @property
    def PROGRAM_NAMES(self) -> list[str]:
        """Program names to search for in PATH"""
        return ["mopac"]

    @classmethod
    def extend_parser(cls, parser: ArgumentParser) -> None:
        """Add mopac parsing options.

        Parameters
        ----------
        parser: ArgumentParser
            Parser that should be extended
        """
        parser.add_argument(
            "--method",
            default="PM6-D3H4X",
            dest="method",
            help="MOPAC method (default: PM6-D3H4X)",
        )
        parser.add_argument("-e", "--exe", dest="prog", help="Path to the MOPAC executable")

    def write_mopac_input(
        self,
        calc_data: CalculationData,
        method: str,
        outputfile: str,
    ) -> None:
        """
        Create a MOPAC input file from the ORCA input variables and the provided XYZ file.

        The MOPAC input file format is as follows:

        {method} 1SCF XYZ MS={spin} CHARGE={charge} THREADS={ncores}[ UHF][ GRADIENTS]
        Generated by ORCA-to-MOPAC wrapper

        <coordinates from xyz file>

        Here the spin is calculated correctly from the mult (2S+1) using:
            S = (mult - 1) * 0.5

        Also:
        - "CHARGE={charge}" reports the total charge of the system.
        - "THREADS={ncores}" sets the number of processors.
        - "UHF" is appended if mult is not 1.
        - "GRADIENTS" is appended if gradient computation is requested.

        Parameters
        ----------
        method: str
            Method to compute with
        calc_data: CalculationData
            Object with calculation data for the run
        outputfile: str
            File to write the MOPAC input to
        """
        with calc_data.xyzfile.open() as f:
            lines = f.readlines()
        # If file is in standard XYZ format (first line is atom count), skip first two lines.
        if lines and lines[0].strip().isdigit():
            coord_lines = lines[2:]
        else:
            coord_lines = lines

        spin = (calc_data.mult - 1) * 0.5
        # Format spin to one decimal place (e.g., "0.5" for a doublet)
        spin_formatted = f"{spin:.1f}"
        header = f"{method} 1SCF XYZ MS={spin_formatted} CHARGE={calc_data.charge} THREADS={calc_data.ncores}"
        if calc_data.mult != 1:
            header += " UHF"
        if calc_data.dograd:
            header += " GRADIENTS"

        with Path(outputfile).open("w") as f_out:
            f_out.write(header + "\n")
            f_out.write("Generated by ORCA-to-MOPAC wrapper\n\n")
            for line in coord_lines:
                f_out.write(line)

    def read_mopac_out(self, calc_data: CalculationData, natoms: int) -> tuple[float, list[float]]:
        """
        Read the output from MOPAC.

        It extracts the energy (by finding the "FINAL HEAT OF FORMATION" line)
        and, if requested, reads the gradient from the corresponding output block.

        The energy is originally in kcal/mol and the gradient components in kcal/Å.
        They are converted to atomic units as follows:
          - Energy: 1 kcal/mol = 1/627.5095 Eh
          - Gradient: 1 (kcal/Å) = (1/627.5095) / 1.889725988 Eh/Bohr

        Parameters
        ----------
        calc_data: CalculationData
            Object with calculation data for the run
        natoms : int
            Number of atoms in the system.

        Returns
        -------
        energy : The computed energy in Eh.
        gradient : The gradient in Eh/Bohr (if computed), as a flat list of floats.
        """
        energy = None
        gradient = []
        mopac_out = check_path(calc_data.basename + ".out")
        print("Checking:", mopac_out)
        with mopac_out.open() as f:
            for line in f:
                if "FINAL HEAT OF FORMATION" in line:
                    # Expect a line like: "FINAL HEAT OF FORMATION =   -123.456 ..."
                    tokens = line.split()
                    if "=" in tokens:
                        idx = tokens.index("=")
                        try:
                            # Convert energy from kcal/mol to Eh.
                            energy = float(tokens[idx + 1]) * (1 / ENERGY_CONVERSION["kcal/mol"])
                        except (IndexError, ValueError):
                            pass
                        break

        if energy is None:
            print("Could not find energy in MOPAC output.")
            sys.exit(1)

        if calc_data.dograd:
            # Read the entire output file into memory.
            with mopac_out.open() as f:
                lines = f.readlines()

            # Locate the header of the gradient table.
            header_idx = None
            for i, line in enumerate(lines):
                if "PARAMETER" in line and "GRADIENT" in line:
                    header_idx = i + 1  # Data is expected to start on the next line.
                    break
            if header_idx is None:
                print("Could not find gradient header in MOPAC output.")
                sys.exit(1)

            # Process the gradient table: each line should correspond to one gradient component.
            for line in lines[header_idx:]:
                line = line.strip()
                if not line:
                    continue  # Skip empty lines.
                tokens = line.split()
                # Expect at least 7 tokens:
                # [0]: parameter index, [1]: atom number, [2]: element,
                # [3] & [4]: coordinate description (e.g., "CARTESIAN X"),
                # [5]: VALUE, [6]: GRADIENT, [7] (if present): unit.
                if len(tokens) < 7:
                    continue
                try:
                    # Extract the gradient value (seventh token) in kcal/Å and convert it to Eh/Bohr.
                    grad_val = float(tokens[6]) * (
                        (1 / ENERGY_CONVERSION["kcal/mol"]) / (1 / LENGTH_CONVERSION["Ang"])
                    )
                except ValueError:
                    continue
                gradient.append(grad_val)
                # Stop once we have gathered the expected 3 * natoms entries.
                if len(gradient) >= 3 * natoms:
                    break

            if len(gradient) != 3 * natoms:
                print(
                    f"Gradient entries ({len(gradient)}) do not match expected 3x number of atoms ({3 * natoms})."
                )
                sys.exit(1)

        return energy, gradient

    def run_mopac(
        self,
        calc_data: CalculationData,
        mopac_inp: str,
        args: list[str],
    ) -> None:
        """
        Run the MOPAC program with the given input file and redirect its STDOUT and STDERR to a logfile.

        Parameters
        ----------
        calc_data: CalculationData
            Object with calculation data for the run
        mopac_inp : str
            The generated MOPAC input file.
        args: list[str]
            Additional arguments not parsed so far
        """
        # Add method to the clear args
        args.insert(0, mopac_inp)
        if not calc_data.prog_path:
            raise RuntimeError("Path to program is None.")
        run_command(calc_data.prog_path, calc_data.output_file, args)

    def calc(
        self, calc_data: CalculationData, args_parsed: dict[str, Any], args_not_parsed: list[str]
    ) -> tuple[float, list[float]]:
        """
        Routine for calculating energy and optional gradient.
        Writes ORCA output

        Parameters
        ----------
        calc_data: CalculationData
            Object with calculation data for the run
        args_parsed: dict[str, Any]
            Arguments parsed as defined in extend_parser
        args_not_parsed: list[str]
            Arguments not parsed so far

        Returns
        -------
        float: energy
        list[float]: gradients
        """
        # Get options that were parsed
        prog = args_parsed.get("prog")
        method = args_parsed.get("method")
        if not isinstance(method, str):
            raise RuntimeError("Problems detecting method.")
        # Set and check the program path if its executable
        calc_data.set_program_path(prog)
        if calc_data.prog_path:
            print(f"Using executable {calc_data.prog_path}")
        else:
            raise FileNotFoundError(
                f"Could not find a valid executable from standard program names: {self.PROGRAM_NAMES}"
            )
        # Set name for MOPAC input
        mopac_inp = calc_data.basename + ".mop"

        # Write Mopac input
        self.write_mopac_input(
            calc_data=calc_data,
            method=method,
            outputfile=mopac_inp,
        )

        # run mopac
        self.run_mopac(calc_data=calc_data, mopac_inp=mopac_inp, args=args_not_parsed)

        # get the number of atoms from the xyz file
        natoms = nat_from_xyzfile(xyz_file=calc_data.xyzfile)

        # parse the mopac output
        energy, gradient = self.read_mopac_out(calc_data=calc_data, natoms=natoms)

        return energy, gradient


def main() -> None:
    """
    Main routine for execution
    """
    calculator = MopacCalc()
    inputfile, args, args_not_parsed = calculator.parse_args()
    calculator.run(inputfile=inputfile, args_parsed=args, args_not_parsed=args_not_parsed)


# Python entry point
if __name__ == "__main__":
    main()
