import io
import os
from pathlib import Path

import numpy as np
import pytest
from ase import Atoms
from ase.calculators.calculator import Calculator, all_changes


EV_TO_EH = 1.0 / 27.21138625
ANG_TO_BOHR = 0.529177210903
FORCE_TO_GRAD = -ANG_TO_BOHR / 27.21138625


class DummyCalc(Calculator):
    implemented_properties = ["energy", "forces"]

    def __init__(self, energy_eV: float, forces_eVA: np.ndarray):
        super().__init__()
        self._energy = float(energy_eV)
        self._forces = np.array(forces_eVA, dtype=float)

    def calculate(self, atoms=None, properties=("energy", "forces"), system_changes=all_changes):
        super().calculate(atoms, properties, system_changes)
        self.results["energy"] = self._energy
        self.results["forces"] = self._forces


def write_extinp(tmpdir: Path, name: str, symbols: list[str], coords: list[tuple[float, float, float]], charge=0, mult=1, ncores=1, dograd=1) -> Path:
    xyz = tmpdir / f"{name}_EXT.xyz"
    with xyz.open("w") as fh:
        fh.write(f"{len(symbols)}\n")
        fh.write("generated by test\n")
        for s, (x, y, z) in zip(symbols, coords):
            fh.write(f"{s} {x} {y} {z}\n")

    extinp = tmpdir / f"{name}_EXT.extinp.tmp"
    with extinp.open("w") as fh:
        fh.write(str(xyz) + "\n")
        fh.write(str(charge) + "\n")
        fh.write(str(mult) + "\n")
        fh.write(str(ncores) + "\n")
        fh.write(str(dograd) + "\n")
    return extinp


def read_engrad(path: Path):
    with path.open() as fh:
        lines = [l.strip() for l in fh.readlines()]
    # lines structure: comments + natoms + comments + energy + [grad]
    # find the first numeric after the "Total energy" header
    energy_idx = None
    for i, l in enumerate(lines):
        if l.startswith("# Total energy"):
            energy_idx = i + 2  # next non-comment is energy line
            break
    assert energy_idx is not None
    energy = float(lines[energy_idx])
    # gradient lines are all numeric after the gradient header
    grad = []
    grad_header_idx = None
    for i, l in enumerate(lines):
        if l.startswith("# Gradient"):
            grad_header_idx = i + 2
            break
    if grad_header_idx is not None:
        for l in lines[grad_header_idx:]:
            if not l or l.startswith("#"):
                break
            grad.append(float(l))
    return energy, grad


def test_standalone_omol_basic(tmp_path, monkeypatch):
    from maceexttool import standalone

    # One H2 molecule; energy 1 eV, zero forces
    extinp = write_extinp(tmp_path, "h2", ["H", "H"], [(0, 0, 0), (0, 0, 0.75)])

    def fake_init(**kwargs):
        # energy in eV; forces in eV/Ang
        return DummyCalc(energy_eV=1.0, forces_eVA=np.zeros((2, 3)))

    monkeypatch.setattr("maceexttool.calculator.init", lambda **kwargs: fake_init(**kwargs))

    standalone.run(["-s", "omol", str(extinp)])

    engrad = Path(str(extinp).replace(".extinp.tmp", ".engrad")).with_suffix(".engrad")
    energy, grad = read_engrad(engrad)
    assert pytest.approx(1.0 * EV_TO_EH, rel=1e-8) == energy
    assert all(abs(g) < 1e-15 for g in grad)


def test_standalone_mp_extras_and_defaults(tmp_path, monkeypatch):
    from maceexttool import standalone

    extinp = write_extinp(tmp_path, "h1", ["H"], [(0, 0, 0)])

    calls = {}

    def rec_init(**kwargs):
        calls.update(kwargs)
        # one-atom, unit forces
        return DummyCalc(energy_eV=2.0, forces_eVA=np.ones((1, 3)))

    monkeypatch.setattr("maceexttool.calculator.init", lambda **kwargs: rec_init(**kwargs))

    standalone.run(["-s", "mp", "--dispersion", "--head", "mh0", str(extinp)])

    # defaults for mp: float32 if not provided
    assert calls.get("default_dtype") == "float32"
    assert calls.get("dispersion") is True
    assert calls.get("head") == "mh0"

    engrad = Path(str(extinp).replace(".extinp.tmp", ".engrad")).with_suffix(".engrad")
    energy, grad = read_engrad(engrad)
    assert pytest.approx(2.0 * EV_TO_EH, rel=1e-8) == energy
    # gradient per component should be FORCE_TO_GRAD
    assert len(grad) == 3
    for g in grad:
        assert pytest.approx(FORCE_TO_GRAD, rel=1e-8) == g


def test_suite_synonyms_are_normalized(tmp_path, monkeypatch):
    from maceexttool import standalone

    extinp = write_extinp(tmp_path, "w", ["H"], [(0, 0, 0)])

    seen = {}

    def check_suite(**kwargs):
        seen["suite"] = kwargs.get("suite")
        return DummyCalc(energy_eV=0.0, forces_eVA=np.zeros((1, 3)))

    monkeypatch.setattr("maceexttool.calculator.init", lambda **kwargs: check_suite(**kwargs))
    standalone.run(["-s", "mace-omol", str(extinp)])
    assert seen.get("suite") == "omol"


def test_server_route_with_dummy_calc(monkeypatch):
    import json
    from maceexttool import server

    server._suite = "omol"
    server._model = None
    server._default_dtype = "float64"
    server._device = ""
    server._dispersion = False
    server._head = None
    server.calculators.clear()

    monkeypatch.setattr(
        "maceexttool.calculator.init",
        lambda **kwargs: DummyCalc(energy_eV=3.0, forces_eVA=np.zeros((2, 3))),
    )

    client = server.app.test_client()
    payload = {
        "atom_types": ["H", "H"],
        "coordinates": [[0, 0, 0], [0, 0, 0.74]],
        "charge": 0,
        "mult": 1,
        "nthreads": 1,
    }
    resp = client.post("/calculate", json=payload)
    assert resp.status_code == 200
    data = resp.get_json()
    assert pytest.approx(3.0 * EV_TO_EH, rel=1e-8) == data["energy"]
    assert all(abs(g) < 1e-15 for g in data["gradient"])  # zero forces


def test_client_writes_engrad_via_stubbed_requests(tmp_path, monkeypatch):
    from maceexttool import client, server

    # Prepare ORCA input
    extinp = write_extinp(tmp_path, "h2c", ["H", "H"], [(0, 0, 0), (0, 0, 0.74)])

    # stub requests.post to route to Flask test client
    flask_client = server.app.test_client()
    def post_stub(url, json=None, **kwargs):  # noqa: A002
        # ignore url, directly call app
        resp = flask_client.post("/calculate", json=json)
        # mimic requests.Response subset
        class R:
            def __init__(self, resp):
                self._resp = resp
                self.status_code = resp.status_code
            def raise_for_status(self):
                if not (200 <= self.status_code < 300):
                    raise RuntimeError("HTTP error")
            def json(self):
                return self._resp.get_json()
        return R(resp)

    # route server to a dummy calc
    server.calculators.clear()
    monkeypatch.setattr(
        "maceexttool.calculator.init",
        lambda **kwargs: DummyCalc(energy_eV=4.0, forces_eVA=np.zeros((2, 3))),
    )
    monkeypatch.setattr("maceexttool.client.requests.post", post_stub)

    client.run([str(extinp)])

    engrad = Path(str(extinp).replace(".extinp.tmp", ".engrad")).with_suffix(".engrad")
    energy, grad = read_engrad(engrad)
    assert pytest.approx(4.0 * EV_TO_EH, rel=1e-8) == energy
    assert all(abs(g) < 1e-15 for g in grad)
